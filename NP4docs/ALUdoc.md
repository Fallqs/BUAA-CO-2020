## ALU(Arithmetic Logic Unit)

### 概览

两位同学将在本单元协作完成ALU的设计搭建与测试。

ALU的功能大家应该已经非常熟悉，不必再作展开。虽然我们的ALU结构比较简单，却仍然有人因为不注意代码规范性等原因出现错误，希望同学们不要掉以轻心。

在我们的CPU中，ALU支持符号、无符号加减法，按位与、或、异或、取反，逻辑左右移位以及算术右移。拥有一个64位输入口(2\*32)，一个32位输出口以及一个控制信号口。

ALU的功能分为**基础功能**和**扩展功能**两部分，只实现**基础功能**即可通过课程，但总评将受影响。

**基础功能**：无符号加减法；按位与.

**扩展功能**：符号加减法；按位与、按位异或、按位取反；逻辑、算术移位.

\*器件外观和测试点输出格式请与**器件外观**和**测试要求**中的模板代码保持完全一致，以免在互测阶段造成不必要的麻烦.

\*关于基础功能和扩展功能的详细要求请仔细查阅**行为规范**.

### 器件外观

```verilog
module ALU(
    input wire [3:0]ctrlIn,
    input wire [63:0]dataIn,
    output wire [31:0]dataOut
);
...
endmodule
```

ALU的输入输出信号有：

1. 来自控制器的4位控制信号`ctrIn`。ALU根据`ctrlIn`的取值完成相应动作。
2. 包含两个操作数的64位输入信号`dataIn`。`dataIn`的高32位是第一个操作数，记作`x`；`dataIn`的低32位是第二个操作数，记作`y`。模块内部可用`assign {x, y} = dataIn;` 获得这两个信号。
3. 代表计算结果的32位输出信号`dataOut`，记作`z`。

### 行为规范

1. 任意时刻，ALU的行为只与`ctrlIn`有关，`z` 的取值按照下表计算：
   
   | ctrlIn  | z            | 含义     |
   | ------- | ------------ | ------ |
   | 0, >=11 | x            | 将x原样输出 |
   | 1       | x + y        | 无符号加   |
   | 2       | x - y        | 无符号减   |
   | 3       | x \| y       | 按位或    |
   | 4       | x ^ y        | 按位异或   |
   | 5       | x & y        | 按位与    |
   | 6       | x + y        | 符号加    |
   | 7       | x - y        | 符号减    |
   | 8       | x << y[4:0]  | 逻辑左移   |
   | 9       | x >> y[4:0]  | 逻辑右移   |
   | 10      | x >>> y[4:0] | 算术右移   |
   
   \*表中出现的数字均为10进制.

### 测试要求

1. 提供两个精心构造的测试点，一个仅测试基础功能，一个允许测试所有功能但须覆盖扩展功能。

2. tb文件要求在以下模板基础上修改得到：
   
   ```verilog
   module aluTB;
       // signal definition
       reg [3:0] ctrlIn;
       reg [31:0] x;
       reg [31:0] y;
       wire [31:0] z;
   
       // instantiation
       ALU uut(.ctrlIn(ctrlIn), .dataIn({x, y}), .dataOut(z));
   
       //excitaion
       initial begin
           #2;
           // your codes here
           // sample:
           // #4 {x, y, ctrlIn} = {32'hffff, 32'heeee, 4'd2};
       end
   
       // display
       always #4 $display("%h [%0d] %h => %h", x, ctrlIn, y, z);
   endmodule
   ```
   
   \*注意每次输入改变之前需延时4个时间单位.

3. 可以使用c/c++、python等语言编写程序生成有一定强度的测试点。

4. 如果tb中使用了verilog文件读写技巧，记得将数据文件一并提交。
   
   *(vivado)数据文件放在`工程目录/工程名.sim/sim_1/behav/xsim/`目录下才能正常仿真

5. 每个测试点提供一个`coverage.txt`文件，写明你的测试点覆盖了哪些情况，与`tb.v`和其他文件一并提交，并将内容附在实验报告相关章节里。测试点强度将纳入总评，在`coverage.txt`中明确说明在这些情况下正确的电路将产生什么输出、不正确的电路将产生什么输出，不能在输出中体现的测试内容将被视作无效。
