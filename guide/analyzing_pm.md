# Path Manager(PM) 解析

PM是本方案中处理接线的唯一一个器件，通过二维数组的引入、借助函数式编程的概念，可以在P5阶段实现优于AT法的冒险控制方案。同时，极高的集成度也使得CPU的其他部分相比于P4不需要做任何改动。



## 流水线

+ 本设计有且仅有两条数据总线，它们组成了流水线的主干，这就是源码第 35 行的 $bus$ 数组。$bus$ 数组从ALU的输入级(你可以认为是D/E级也可以认为是E级)开始编号，0级代表ALU的输入级，1级代表ALU的输出级和DM的输入级，2级代表DM的输出级和GRF的写回级，依次类推。
+ $bus$ 中每个位置存放了对应总线编号、对应流水级中的计算解结果。
+ 最高有第7级，这是为转发而做的“超流水”或者“过流水”，当然，也许并不需要做到第7级。



## 标志体系

+ 建立标志体系是为了追踪数值计算在流水线中的完成情况。注意到一个流水级只存在一条指令，每条指令又至多只有一个写回值，我们只需维护 $id$ 和 $line$ 两个数组，分别记录在第 $i$ 个流水级上，写回的是哪个寄存器，数值处在哪条总线上。具体地说，当前第 $i$ 级指令要回写 $id[i]$ 号寄存器，数值处在 $line[i]$ 号总线上。
+ 考虑如何给输入端口提供信息。通常认为，操作数有时来自正常的流水，有时来自转发。但不妨把操作数看成是流水线的函数，进一步地，把取得操作数的位置看成流水线的函数，不妨称作**数据来源函数**。具体地，依次比对 $id[1],di[2],\cdots$ 看与操作数的寄存器号是否相等，相等意味着前序指令改变了操作数的值，且尚未写回寄存器堆中，显然这时需要从流水线(也就是$bus$数组)中读出操作数的正确数值。因此我们记录对应的 $line[i]$，并计算出使用时操作数所在的流水级($i+C$，$C$为一个与器件相关的常量)，等待使用时取用即可。
+ 以上做法可以使用for循环实现，我用枚举的方式实现得比较笨拙，另外，verilog的for循环是$\mathcal{O}(1)$的。
+ 考虑如果 $i+C$ 小于数值最初有效的流水级该如何处理。比如说前序指令是取数指令，当前指令是加法指令，当加法指令执行到给ALU提供操作数时，操作数本身尚未从DM中取出来，这会导致错误。显然此时应该暂缓向流水线中发射这条加法指令，继续执行前序指令，直到 $i+C\ge S$ ，即大于等于最初有效的流水级为止。



## 代码分析

+ 15-27行：计算并流水**数据来源函数** $falux,faluy, fdmx, fcmpx, fcmpy, frfz$ 。其中 $frfz$ 表示GRF的z号端口应当输出的数值，提供给IFU，用于 $jr,jalr$ 等指令。
+ 29-31行：计算暂停条件，其中 $su[]$ 就是上一节所提 $S$，以parameter的形式定义在了第10行。
+ 37-40行：流水线数据的读入
+ 41-58行：流水线数据的流水
+ 62-68行：用数据来源函数计算各器件输入端口的数值并赋值
+ 70行：内置比较器
